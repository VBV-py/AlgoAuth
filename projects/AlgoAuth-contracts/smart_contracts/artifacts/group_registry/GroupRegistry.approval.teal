#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock "ms" 0x000a 0x151f7c75 0x0020 "mr" "groupCount" "gn" "gc"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/group_registry/contract.algo.ts:5
    // groupCount = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec 5 // "groupCount"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/group_registry/contract.algo.ts:4
    // export class GroupRegistry extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@19
    pushbytess 0xa73f1fbc 0x7c4a93e6 0x9a69da00 0xc44bbeff 0x88ded0b7 0x648f4fd3 0x15967c17 0x2d5af651 0xea2caa30 0x9ee5b256 0x6f818e78 0x4b0c055f 0xaf6977b7 // method "createGroup(string)uint64", method "inviteMember(uint64,string)void", method "acceptInvite(uint64)void", method "rejectInvite(uint64)void", method "removeMember(uint64,string)void", method "leaveGroup(uint64)void", method "getGroupName(uint64)string", method "getGroupCreator(uint64)string", method "getMemberStatus(uint64,string)uint64", method "getMemberRole(uint64,string)uint64", method "isMember(uint64,string)bool", method "isAdmin(uint64,string)bool", method "getGroupCount()uint64"
    txna ApplicationArgs 0
    match createGroup inviteMember acceptInvite rejectInvite removeMember leaveGroup getGroupName getGroupCreator getMemberStatus getMemberRole isMember isAdmin getGroupCount
    err

main_create_NoOp@19:
    // smart_contracts/group_registry/contract.algo.ts:4
    // export class GroupRegistry extends Contract {
    pushbytes 0xb8447b36 // method "createApplication()void"
    txna ApplicationArgs 0
    match main_createApplication_route@20
    err

main_createApplication_route@20:
    // smart_contracts/group_registry/contract.algo.ts:5
    // groupCount = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec 5 // "groupCount"
    // smart_contracts/group_registry/contract.algo.ts:15
    // this.groupCount.value = Uint64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/group_registry/contract.algo.ts:13
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.createGroup[routing]() -> void:
createGroup:
    // smart_contracts/group_registry/contract.algo.ts:18
    // @abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/group_registry/contract.algo.ts:20
    // this.groupCount.value = this.groupCount.value + Uint64(1)
    intc_0 // 0
    // smart_contracts/group_registry/contract.algo.ts:5
    // groupCount = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec 5 // "groupCount"
    // smart_contracts/group_registry/contract.algo.ts:20
    // this.groupCount.value = this.groupCount.value + Uint64(1)
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/group_registry/contract.algo.ts:5
    // groupCount = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec 5 // "groupCount"
    // smart_contracts/group_registry/contract.algo.ts:20
    // this.groupCount.value = this.groupCount.value + Uint64(1)
    dig 1
    app_global_put
    // smart_contracts/group_registry/contract.algo.ts:23
    // this.groupNames(groupId).value = name
    itob
    // smart_contracts/group_registry/contract.algo.ts:7
    // groupNames = BoxMap<uint64, string>({ keyPrefix: 'gn' })
    bytec 6 // "gn"
    dig 1
    concat
    // smart_contracts/group_registry/contract.algo.ts:23
    // this.groupNames(groupId).value = name
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/group_registry/contract.algo.ts:24
    // this.groupCreators(groupId).value = Txn.sender.bytes.toString()
    txn Sender
    // smart_contracts/group_registry/contract.algo.ts:8
    // groupCreators = BoxMap<uint64, string>({ keyPrefix: 'gc' })
    bytec 7 // "gc"
    dig 2
    concat
    // smart_contracts/group_registry/contract.algo.ts:24
    // this.groupCreators(groupId).value = Txn.sender.bytes.toString()
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/group_registry/contract.algo.ts:26
    // const key = { groupId: groupId, user: Txn.sender.bytes.toString() }
    bytec_3 // 0x0020
    txn Sender
    concat
    dig 1
    bytec_1 // 0x000a
    concat
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    dig 1
    concat
    // smart_contracts/group_registry/contract.algo.ts:27
    // this.memberStatuses(key).value = Uint64(2)
    intc_2 // 2
    itob
    box_put
    // smart_contracts/group_registry/contract.algo.ts:11
    // memberRoles = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'mr' })
    bytec 4 // "mr"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:28
    // this.memberRoles(key).value = Uint64(1)
    intc_1 // 1
    itob
    box_put
    // smart_contracts/group_registry/contract.algo.ts:18
    // @abimethod()
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.inviteMember[routing]() -> void:
inviteMember:
    // smart_contracts/group_registry/contract.algo.ts:33
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/group_registry/contract.algo.ts:35
    // const callerKey = { groupId: groupId, user: Txn.sender.bytes.toString() }
    txn Sender
    uncover 2
    itob
    bytec_3 // 0x0020
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    dup
    uncover 2
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    dig 1
    concat
    // smart_contracts/group_registry/contract.algo.ts:36
    // assert(this.memberStatuses(callerKey).exists, 'Caller is not a member')
    dup
    box_len
    bury 1
    assert // Caller is not a member
    // smart_contracts/group_registry/contract.algo.ts:37
    // assert(this.memberStatuses(callerKey).value === Uint64(2), 'Caller has not joined')
    box_get
    pop
    btoi
    intc_2 // 2
    ==
    assert // Caller has not joined
    // smart_contracts/group_registry/contract.algo.ts:11
    // memberRoles = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'mr' })
    bytec 4 // "mr"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:38
    // assert(this.memberRoles(callerKey).value === Uint64(1), 'Caller is not admin')
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    ==
    assert // Caller is not admin
    // smart_contracts/group_registry/contract.algo.ts:40
    // const userKey = { groupId: groupId, user: user }
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    dig 1
    concat
    // smart_contracts/group_registry/contract.algo.ts:41
    // this.memberStatuses(userKey).value = Uint64(1)
    intc_1 // 1
    itob
    box_put
    // smart_contracts/group_registry/contract.algo.ts:11
    // memberRoles = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'mr' })
    bytec 4 // "mr"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:42
    // this.memberRoles(userKey).value = Uint64(0)
    intc_0 // 0
    itob
    box_put
    // smart_contracts/group_registry/contract.algo.ts:33
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.acceptInvite[routing]() -> void:
acceptInvite:
    // smart_contracts/group_registry/contract.algo.ts:45
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/group_registry/contract.algo.ts:47
    // const key = { groupId: groupId, user: Txn.sender.bytes.toString() }
    txn Sender
    swap
    itob
    bytec_3 // 0x0020
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:48
    // assert(this.memberStatuses(key).exists, 'No invite found')
    dup
    box_len
    bury 1
    assert // No invite found
    // smart_contracts/group_registry/contract.algo.ts:49
    // assert(this.memberStatuses(key).value === Uint64(1), 'Not invited')
    dup
    box_get
    pop
    btoi
    intc_1 // 1
    ==
    assert // Not invited
    // smart_contracts/group_registry/contract.algo.ts:50
    // this.memberStatuses(key).value = Uint64(2)
    intc_2 // 2
    itob
    box_put
    // smart_contracts/group_registry/contract.algo.ts:45
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.rejectInvite[routing]() -> void:
rejectInvite:
    // smart_contracts/group_registry/contract.algo.ts:53
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/group_registry/contract.algo.ts:55
    // const key = { groupId: groupId, user: Txn.sender.bytes.toString() }
    txn Sender
    swap
    itob
    bytec_3 // 0x0020
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:56
    // assert(this.memberStatuses(key).exists, 'No invite found')
    dup
    box_len
    bury 1
    assert // No invite found
    // smart_contracts/group_registry/contract.algo.ts:57
    // assert(this.memberStatuses(key).value === Uint64(1), 'Not invited')
    dup
    box_get
    pop
    btoi
    intc_1 // 1
    ==
    assert // Not invited
    // smart_contracts/group_registry/contract.algo.ts:58
    // this.memberStatuses(key).value = Uint64(0)
    intc_0 // 0
    itob
    box_put
    // smart_contracts/group_registry/contract.algo.ts:53
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.removeMember[routing]() -> void:
removeMember:
    // smart_contracts/group_registry/contract.algo.ts:61
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/group_registry/contract.algo.ts:63
    // const callerKey = { groupId: groupId, user: Txn.sender.bytes.toString() }
    txn Sender
    uncover 2
    itob
    bytec_3 // 0x0020
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    dup
    uncover 2
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    dig 1
    concat
    // smart_contracts/group_registry/contract.algo.ts:64
    // assert(this.memberStatuses(callerKey).exists, 'Caller is not a member')
    dup
    box_len
    bury 1
    assert // Caller is not a member
    // smart_contracts/group_registry/contract.algo.ts:65
    // assert(this.memberStatuses(callerKey).value === Uint64(2), 'Caller has not joined')
    box_get
    pop
    btoi
    intc_2 // 2
    ==
    assert // Caller has not joined
    // smart_contracts/group_registry/contract.algo.ts:11
    // memberRoles = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'mr' })
    bytec 4 // "mr"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:66
    // assert(this.memberRoles(callerKey).value === Uint64(1), 'Caller is not admin')
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    ==
    assert // Caller is not admin
    // smart_contracts/group_registry/contract.algo.ts:68
    // const userKey = { groupId: groupId, user: user }
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:69
    // this.memberStatuses(userKey).value = Uint64(0)
    intc_0 // 0
    itob
    box_put
    // smart_contracts/group_registry/contract.algo.ts:61
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.leaveGroup[routing]() -> void:
leaveGroup:
    // smart_contracts/group_registry/contract.algo.ts:72
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/group_registry/contract.algo.ts:74
    // const key = { groupId: groupId, user: Txn.sender.bytes.toString() }
    txn Sender
    swap
    itob
    bytec_3 // 0x0020
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:75
    // assert(this.memberStatuses(key).exists, 'Not a member')
    dup
    box_len
    bury 1
    assert // Not a member
    // smart_contracts/group_registry/contract.algo.ts:76
    // assert(this.memberStatuses(key).value === Uint64(2), 'Not joined')
    dup
    box_get
    pop
    btoi
    intc_2 // 2
    ==
    assert // Not joined
    // smart_contracts/group_registry/contract.algo.ts:77
    // this.memberStatuses(key).value = Uint64(0)
    intc_0 // 0
    itob
    box_put
    // smart_contracts/group_registry/contract.algo.ts:72
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getGroupName[routing]() -> void:
getGroupName:
    // smart_contracts/group_registry/contract.algo.ts:80
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/group_registry/contract.algo.ts:82
    // assert(this.groupNames(groupId).exists, 'Group does not exist')
    itob
    // smart_contracts/group_registry/contract.algo.ts:7
    // groupNames = BoxMap<uint64, string>({ keyPrefix: 'gn' })
    bytec 6 // "gn"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:82
    // assert(this.groupNames(groupId).exists, 'Group does not exist')
    dup
    box_len
    bury 1
    assert // Group does not exist
    // smart_contracts/group_registry/contract.algo.ts:83
    // return this.groupNames(groupId).value
    box_get
    pop
    // smart_contracts/group_registry/contract.algo.ts:80
    // @abimethod({ readonly: true })
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getGroupCreator[routing]() -> void:
getGroupCreator:
    // smart_contracts/group_registry/contract.algo.ts:86
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/group_registry/contract.algo.ts:88
    // assert(this.groupCreators(groupId).exists, 'Group does not exist')
    itob
    // smart_contracts/group_registry/contract.algo.ts:8
    // groupCreators = BoxMap<uint64, string>({ keyPrefix: 'gc' })
    bytec 7 // "gc"
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:88
    // assert(this.groupCreators(groupId).exists, 'Group does not exist')
    dup
    box_len
    bury 1
    assert // Group does not exist
    // smart_contracts/group_registry/contract.algo.ts:89
    // return this.groupCreators(groupId).value
    box_get
    pop
    // smart_contracts/group_registry/contract.algo.ts:86
    // @abimethod({ readonly: true })
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getMemberStatus[routing]() -> void:
getMemberStatus:
    // smart_contracts/group_registry/contract.algo.ts:92
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/group_registry/contract.algo.ts:94
    // const key = { groupId: groupId, user: user }
    swap
    itob
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    swap
    concat
    dup
    // smart_contracts/group_registry/contract.algo.ts:95
    // if (this.memberStatuses(key).exists) {
    box_len
    bury 1
    bz getMemberStatus_after_if_else@3
    // smart_contracts/group_registry/contract.algo.ts:96
    // return this.memberStatuses(key).value
    dup
    box_get
    assert // Box must have value
    btoi

getMemberStatus_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getMemberStatus@4:
    // smart_contracts/group_registry/contract.algo.ts:92
    // @abimethod({ readonly: true })
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getMemberStatus_after_if_else@3:
    // smart_contracts/group_registry/contract.algo.ts:98
    // return Uint64(0)
    intc_0 // 0
    // smart_contracts/group_registry/contract.algo.ts:92
    // @abimethod({ readonly: true })
    b getMemberStatus_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getMemberStatus@4


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getMemberRole[routing]() -> void:
getMemberRole:
    // smart_contracts/group_registry/contract.algo.ts:101
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/group_registry/contract.algo.ts:103
    // const key = { groupId: groupId, user: user }
    swap
    itob
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:11
    // memberRoles = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'mr' })
    bytec 4 // "mr"
    swap
    concat
    dup
    // smart_contracts/group_registry/contract.algo.ts:104
    // if (this.memberRoles(key).exists) {
    box_len
    bury 1
    bz getMemberRole_after_if_else@3
    // smart_contracts/group_registry/contract.algo.ts:105
    // return this.memberRoles(key).value
    dup
    box_get
    assert // Box must have value
    btoi

getMemberRole_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getMemberRole@4:
    // smart_contracts/group_registry/contract.algo.ts:101
    // @abimethod({ readonly: true })
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getMemberRole_after_if_else@3:
    // smart_contracts/group_registry/contract.algo.ts:107
    // return Uint64(0)
    intc_0 // 0
    // smart_contracts/group_registry/contract.algo.ts:101
    // @abimethod({ readonly: true })
    b getMemberRole_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getMemberRole@4


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.isMember[routing]() -> void:
isMember:
    // smart_contracts/group_registry/contract.algo.ts:110
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/group_registry/contract.algo.ts:112
    // const key = { groupId: groupId, user: user }
    swap
    itob
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    swap
    concat
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    swap
    concat
    dup
    // smart_contracts/group_registry/contract.algo.ts:113
    // if (this.memberStatuses(key).exists) {
    box_len
    bury 1
    bz isMember_after_if_else@3
    // smart_contracts/group_registry/contract.algo.ts:114
    // return this.memberStatuses(key).value === Uint64(2)
    dup
    box_get
    assert // Box must have value
    btoi
    intc_2 // 2
    ==

isMember_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.isMember@4:
    // smart_contracts/group_registry/contract.algo.ts:110
    // @abimethod({ readonly: true })
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

isMember_after_if_else@3:
    // smart_contracts/group_registry/contract.algo.ts:116
    // return false
    intc_0 // 0
    // smart_contracts/group_registry/contract.algo.ts:110
    // @abimethod({ readonly: true })
    b isMember_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.isMember@4


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.isAdmin[routing]() -> void:
isAdmin:
    intc_0 // 0
    // smart_contracts/group_registry/contract.algo.ts:119
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/group_registry/contract.algo.ts:121
    // const key = { groupId: groupId, user: user }
    swap
    itob
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec_1 // 0x000a
    concat
    swap
    concat
    dup
    // smart_contracts/group_registry/contract.algo.ts:10
    // memberStatuses = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'ms' })
    bytec_0 // "ms"
    swap
    concat
    dup
    // smart_contracts/group_registry/contract.algo.ts:122
    // if (this.memberStatuses(key).exists && this.memberRoles(key).exists) {
    box_len
    bury 1
    bz isAdmin_after_if_else@8
    // smart_contracts/group_registry/contract.algo.ts:11
    // memberRoles = BoxMap<{ groupId: uint64; user: string }, uint64>({ keyPrefix: 'mr' })
    bytec 4 // "mr"
    dig 2
    concat
    dup
    bury 4
    // smart_contracts/group_registry/contract.algo.ts:122
    // if (this.memberStatuses(key).exists && this.memberRoles(key).exists) {
    box_len
    bury 1
    bz isAdmin_after_if_else@8
    // smart_contracts/group_registry/contract.algo.ts:123
    // return this.memberStatuses(key).value === Uint64(2) && this.memberRoles(key).value === Uint64(1)
    dup
    box_get
    assert // Box must have value
    btoi
    intc_2 // 2
    ==
    bz isAdmin_bool_false@6
    dig 2
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    ==
    bz isAdmin_bool_false@6
    intc_1 // 1

isAdmin_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.isAdmin@9:
    // smart_contracts/group_registry/contract.algo.ts:119
    // @abimethod({ readonly: true })
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

isAdmin_bool_false@6:
    intc_0 // 0
    // smart_contracts/group_registry/contract.algo.ts:119
    // @abimethod({ readonly: true })
    b isAdmin_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.isAdmin@9

isAdmin_after_if_else@8:
    // smart_contracts/group_registry/contract.algo.ts:125
    // return false
    intc_0 // 0
    // smart_contracts/group_registry/contract.algo.ts:119
    // @abimethod({ readonly: true })
    b isAdmin_after_inlined_smart_contracts/group_registry/contract.algo.ts::GroupRegistry.isAdmin@9


// smart_contracts/group_registry/contract.algo.ts::GroupRegistry.getGroupCount[routing]() -> void:
getGroupCount:
    // smart_contracts/group_registry/contract.algo.ts:130
    // return this.groupCount.value
    intc_0 // 0
    // smart_contracts/group_registry/contract.algo.ts:5
    // groupCount = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec 5 // "groupCount"
    // smart_contracts/group_registry/contract.algo.ts:130
    // return this.groupCount.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/group_registry/contract.algo.ts:128
    // @abimethod({ readonly: true })
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
